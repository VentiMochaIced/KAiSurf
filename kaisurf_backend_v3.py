# -*- coding: utf-8 -*-
"""KAiSurf Backend v3.0

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UOtiD0FtTbIKNQg6e-1ceqLA7FJLBATR
"""

"""
KAiSurf Login & Affiliate Module - v3.0

This Flask application provides a secure, passwordless authentication system and
introduces a new affiliate management API.

==================================
AI FEEDBACK & UPGRADE SUMMARY (v3.0):
==================================
This version represents a significant enhancement over v2.2, focusing on production-readiness,
user management, and the introduction of a complete Affiliate API. The core authentication
logic remains robust, while the new features provide a clear path for monetization and
advanced user engagement. The code is cleaner, more secure, and better structured for
future expansion.

==================
CHANGE LOG:
==================
Version: 3.0 (Affiliate API, Enhanced Security, Refactoring)

-   **FEATURE (Affiliate Mode API):**
    -   Introduced a full suite of endpoints to manage a domain-level affiliate program.
    -   `POST /user/affiliate/activate`: A new endpoint for users to join the affiliate program.
      Requires a verified email address, linking the secure `roaming_id` to a recoverable
      and verifiable identity for business purposes.
    -   `GET /user/affiliate/status`: Allows an authenticated user to check their affiliate status,
      including their unique referral code.
    -   `User` model updated with `is_affiliate`, `affiliate_email`, and `affiliate_code` fields
      to manage the program at the database level.

-   **SECURITY & AUTHENTICATION:**
    -   **API Key Protection:** Added a simple, static API key (`X-API-Key`) requirement for
      critical endpoints like registration and affiliate activation. In a production environment,
      this should be unique per client application. This prevents unauthorized automated access.
    -   **Enhanced Input Validation:** All endpoints now perform more rigorous checks on incoming
      JSON data to ensure required fields are present, preventing errors and potential abuse.
    -   Refined error messages to be informative for developers but generic for end-users to
      avoid leaking system information.

-   **REFACTORING & BEST PRACTICES:**
    -   **Helper Functions:** Consolidated logic for retrieving the current authenticated user
      into a `get_user_from_auth_header` helper function. This removes redundant code,
      improves readability, and centralizes the authentication checking logic.
    -   **Code Structure:** Reorganized the file with clear sections for Models, Helpers, and
      API Endpoints, adhering to standard Flask application structure.
    -   **Configuration Management:** Moved the API key into the Flask `app.config` for better
      management, allowing it to be set via environment variables in a production deployment.

-   **WEBHOOKS (Conceptual Implementation):**
    -   Added a new endpoint `POST /webhook/chrome/sync` to demonstrate how a browser extension
      or external module could synchronize data with the backend.
    -   This webhook receives a payload (e.g., a new bookmark) and logs it to the user's
      `ChronoLog`, creating a unified activity stream across different user clients.
"""
import json
import datetime
import uuid
from functools import wraps
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)

# --- Configuration ---
# SECURITY: In a real app, this key should be a long, random string from an environment variable.
app.config['SECRET_KEY'] = 'your-super-secret-key-for-production'
app.config['CLIENT_API_KEY'] = 'static-client-api-key-for-demo' # For client app authorization
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///kaisurf_v3.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)

# --- SQLAlchemy ORM Models ---
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    roaming_id = db.Column(db.String(100), unique=True, nullable=False)
    registration_date = db.Column(db.DateTime, default=datetime.datetime.utcnow)

    # Affiliate Program Fields
    is_affiliate = db.Column(db.Boolean, default=False)
    affiliate_email = db.Column(db.String(120), unique=True, nullable=True)
    affiliate_code = db.Column(db.String(50), unique=True, nullable=True)

    # Relationships
    login_records = db.relationship('LoginRecord', backref='user', lazy=True, cascade="all, delete-orphan")
    chrono_logs = db.relationship('ChronoLog', backref='user', lazy=True, cascade="all, delete-orphan")

class LoginRecord(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    login_username = db.Column(db.String(150), nullable=False)
    login_timestamp = db.Column(db.DateTime, default=datetime.datetime.utcnow)

class ChronoLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    activity_type = db.Column(db.String(50), nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.datetime.utcnow)

# --- Decorators for Security ---
def require_api_key(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if request.headers.get('X-API-Key') != app.config['CLIENT_API_KEY']:
            return jsonify({"error": "Invalid or missing client API key."}), 403
        return f(*args, **kwargs)
    return decorated_function

# --- Helper Functions ---
def get_daily_username(roaming_id):
    """Generates the daily username from the roaming ID and current date."""
    today = datetime.date.today().isoformat()
    return f"{roaming_id.split()[0]}-{today}-{roaming_id.split()[1]}"

def add_chrono_log_entry(user_id, activity_type, content):
    """Helper to create new entries in the ChronoLog."""
    log_entry = ChronoLog(user_id=user_id, activity_type=activity_type, content=json.dumps(content))
    db.session.add(log_entry)

def get_user_from_auth_header():
    """Validates the auth header and returns the corresponding user."""
    auth_username = request.headers.get('X-Auth-Username')
    if not auth_username:
        return None, (jsonify({"error": "Authentication username required in X-Auth-Username header."}), 401)

    record = LoginRecord.query.filter_by(login_username=auth_username).order_by(LoginRecord.login_timestamp.desc()).first()
    if not record:
        return None, (jsonify({"error": "Invalid or expired session username."}), 403)

    user = User.query.get(record.user_id)
    if not user:
         return None, (jsonify({"error": "Authenticated user not found."}), 404)

    return user, None

# --- API Endpoints ---

@app.route('/register', methods=['POST'])
@require_api_key
def register():
    """Handles new user registration with user enumeration protection."""
    data = request.get_json()
    if not data or 'roaming_id' not in data:
        return jsonify({"error": "Missing 'roaming_id' in request body."}), 400

    roaming_id = data.get('roaming_id', '').strip()
    if len(roaming_id.split()) != 2:
        return jsonify({"error": "Registration requires a 'roaming_id' of exactly two words."}), 400

    if not User.query.filter_by(roaming_id=roaming_id).first():
        new_user = User(roaming_id=roaming_id)
        db.session.add(new_user)
        db.session.commit()
        add_chrono_log_entry(new_user.id, 'REGISTRATION', {'status': 'Account created.'})
        db.session.commit()

    return jsonify({"message": "Registration request processed."}), 202

@app.route('/login', methods=['POST'])
@require_api_key
def login():
    """Handles user login using the daily-derived username."""
    data = request.get_json()
    if not data or not all(k in data for k in ['roaming_id', 'username']):
        return jsonify({"error": "Roaming ID and username are required."}), 400

    user = User.query.filter_by(roaming_id=data['roaming_id']).first()
    if not user:
        return jsonify({"error": "Invalid credentials."}), 401

    if data['username'] == get_daily_username(data['roaming_id']):
        login_record = LoginRecord(user_id=user.id, login_username=data['username'])
        db.session.add(login_record)
        add_chrono_log_entry(user.id, 'LOGIN', {'status': 'Successful authentication.'})
        db.session.commit()
        return jsonify({"message": "Access Granted", "auth_username": data['username']}), 200
    else:
        return jsonify({"error": "Invalid credentials."}), 401

@app.route('/user/profile', methods=['GET'])
def get_user_profile():
    """A post-login navigation hub, providing user status and options."""
    user, error_response = get_user_from_auth_header()
    if error_response: return error_response

    return jsonify({
        "user_id": user.id,
        "roaming_id_hint": f"{user.roaming_id.split()[0]}...{user.roaming_id.split()[-1]}",
        "is_affiliate": user.is_affiliate,
        "registration_date": user.registration_date.isoformat() + "Z",
    }), 200

# --- Affiliate API Endpoints ---
@app.route('/user/affiliate/activate', methods=['POST'])
def activate_affiliate():
    """Activates affiliate status for the authenticated user."""
    user, error_response = get_user_from_auth_header()
    if error_response: return error_response

    if user.is_affiliate:
        return jsonify({"message": "User is already an affiliate."}), 409

    data = request.get_json()
    if not data or 'email' not in data:
        return jsonify({"error": "Email address is required to become an affiliate."}), 400

    email = data['email']
    if User.query.filter_by(affiliate_email=email).first():
        return jsonify({"error": "This email is already associated with an affiliate account."}), 409

    user.is_affiliate = True
    user.affiliate_email = email
    user.affiliate_code = str(uuid.uuid4())[:8].upper() # Generate a unique referral code

    add_chrono_log_entry(user.id, 'AFFILIATE_ACTIVATION', {'email': email, 'code': user.affiliate_code})
    db.session.commit()

    return jsonify({
        "message": "Affiliate account activated successfully!",
        "affiliate_code": user.affiliate_code
    }), 200

@app.route('/user/affiliate/status', methods=['GET'])
def get_affiliate_status():
    """Checks the affiliate status of the authenticated user."""
    user, error_response = get_user_from_auth_header()
    if error_response: return error_response

    if not user.is_affiliate:
        return jsonify({"is_affiliate": False, "message": "This user is not an affiliate."}), 200

    return jsonify({
        "is_affiliate": True,
        "email": user.affiliate_email,
        "referral_code": user.affiliate_code,
        "joined_date": user.registration_date.isoformat() + "Z" # Should be a separate affiliate join date
    }), 200

# --- Webhook Endpoint ---
@app.route('/webhook/chrome/sync', methods=['POST'])
def webhook_sync():
    """
    Listens for data pushes from a browser module/extension.
    This provides a mechanism for synchronizing user activity (e.g., new bookmarks)
    from different clients into the central ChronoLog.
    """
    user, error_response = get_user_from_auth_header()
    if error_response: return error_response

    data = request.get_json()
    if not data or 'event_type' not in data or 'payload' not in data:
        return jsonify({"error": "Webhook payload must include 'event_type' and 'payload'."}), 400

    add_chrono_log_entry(user.id, f"WEBHOOK_{data['event_type'].upper()}", data['payload'])
    db.session.commit()

    return jsonify({"status": "Webhook event processed."}), 200

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    print("--- KAiSurf Backend v3.0 Initialized ---")
    print("Database ORM is ready. Now with Affiliate API and Webhook support.")
    app.run(debug=True)