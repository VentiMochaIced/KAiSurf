# -*- coding: utf-8 -*-
"""KAiSurf Flask Login App (v2.1)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DVrHCFHncaa2G8Ij39GM8khQZKl4K5I7
"""

"""
KAiSurf Login Module - Conceptual Implementation v2.1

This Flask application demonstrates a novel passwordless authentication system
based on a roaming ID and a daily-changing username.

==================================
AI FEEDBACK & CONCEPTUAL PREMISE (v2.1):
==================================
The evolution of this concept is strong. The core premise of a time-sensitive,
derived username remains a solid passwordless foundation. This version introduces
key architectural and user-flow considerations that move it closer to a real-world
application.

UPGRADEABILITY CONCERNS & SUMMARY:
1.  **Biometric Integration:** The current implementation provides the necessary server-side
    endpoints and database structure to SUPPORT biometric login (e.g., Face ID, fingerprint).
    However, the actual biometric capture and cryptographic signing MUST occur on the
    client-side (e.g., in a mobile app or browser using the WebAuthn API). This app
    is now ready for such a client to be built. The SQLite DB will store the public keys,
    not the biometric data itself, which is a critical security practice.

2.  **Parallel DB / Incentives:** The idea of a parallel email account for incentives is
    a business logic decision. From a security perspective, if this "private network APP"
    is truly isolated (not on the public internet), the risk of data breach is contained.
    However, it's crucial to ensure that the primary `roaming_id` is never directly
    linked to this secondary, potentially less secure, email system in a way that could
    compromise the core authentication. This implementation stores them in separate tables
    to maintain this separation.

3.  **JSON vs. Database RBAC:** The `access_control.json` file is excellent for this
    prototype. For a production system, Role-Based Access Control (RBAC) rules should
    be moved into the database. This would allow for dynamic permissions (e.g., granting
    a user temporary admin rights) without redeploying the application.

==================
CHANGE LOG:
==================
Version: 2.1 (Security Hardening, Biometrics & Onboarding)

-   **SECURITY (User Enumeration):** Implemented a fix for the user enumeration
    vulnerability. The '/register' endpoint now returns a generic, ambiguous success
    message for both new and existing roaming_ids, making it impossible for an attacker
    to determine if a user already exists.

-   **ONBOARDING (Incentives):**
    -   The registration process now "promotes" the platform by offering an incentive.
    -   The response from '/register' now includes a prompt to create a parallel
      "incentive account".
    -   Added a new conceptual table `incentive_accounts` to the database schema to
      demonstrate how this parallel data would be stored securely and separately.

-   **CLARIFICATION (Roaming ID):**
    -   Added extensive comments clarifying that the two-word ID is the **roaming secret**.
      It is APP-SPECIFIC in that it belongs to this service, but it is ROAMING in its
      function, allowing a user to generate the correct daily login from any of their
      devices. Multi-device access is therefore an inherent, primary feature.

-   **FEATURE (Biometric Framework):**
    -   Added a `biometric_keys` table to the database. This table is designed to store
      public keys associated with a user's biometric authenticators (as per WebAuthn/FIDO2
      standards).
    -   Created a new endpoint `/user/profile` which acts as a post-login navigation hub,
      displaying user status and conditional menu options, including biometric setup.
    -   Created a conceptual endpoint `/user/biometric/register-start` to simulate the
      first step of a biometric registration flow.

-   **NAVIGATION & UX:**
    -   The login response now directs the user to the `/user/profile` endpoint to see
      their available actions, improving application flow.
    -   The entire application structure is now more oriented around providing a clear
      user journey after the initial authentication step.
"""
import json
import sqlite3
import datetime
from flask import Flask, request, jsonify

app = Flask(__name__)

DATABASE = 'kaisurf.db'

def get_db_connection():
    """Connects to the SQLite database."""
    conn = sqlite3.connect(DATABASE)
    conn.row_factory = sqlite3.Row
    return conn

def create_tables():
    """Creates the necessary database tables."""
    conn = get_db_connection()
    c = conn.cursor()
    # User table stores the core, high-security roaming ID
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            roaming_id TEXT NOT NULL UNIQUE,
            registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    # Table to record each successful login
    c.execute('''
        CREATE TABLE IF NOT EXISTS login_records (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            login_username TEXT NOT NULL,
            login_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    ''')
    # Conceptual table for the parallel incentive program.
    # Storing this separately from the primary 'users' table prevents
    # potential security issues from a less-secure system (e.g., email)
    # from affecting the core authentication mechanism.
    c.execute('''
        CREATE TABLE IF NOT EXISTS incentive_accounts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER UNIQUE,
            email_address TEXT NOT NULL UNIQUE,
            incentives_unlocked INTEGER DEFAULT 1,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    ''')
    # Table to store public keys for biometric authentication (e.g., WebAuthn)
    # The actual biometric data NEVER leaves the user's device.
    # The device generates a public/private key pair. The public key is stored here.
    c.execute('''
        CREATE TABLE IF NOT EXISTS biometric_keys (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            public_key TEXT NOT NULL,
            device_name TEXT,
            registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    ''')
    conn.commit()
    conn.close()

def get_daily_username(roaming_id):
    """Generates the daily username from the roaming ID and current date."""
    today = datetime.date.today().isoformat()
    words = roaming_id.split()
    if len(words) != 2:
        return None
    # The roaming_id acts as a shared secret between the user and the server,
    # and the date is the changing factor (nonce).
    return f"{words[0]}-{today}-{words[1]}"

@app.route('/register', methods=['POST'])
def register():
    """
    Handles new user registration with user enumeration protection.
    It always returns a generic success message to prevent leaking information
    about whether a roaming_id is already in use.
    """
    data = request.get_json()
    roaming_id = data.get('roaming_id', '').strip()

    if len(roaming_id.split()) != 2:
        return jsonify({"error": "Registration requires a 'roaming_id' consisting of exactly two words."}), 400

    conn = get_db_connection()
    try:
        # Attempt to insert the new user.
        conn.execute('INSERT INTO users (roaming_id) VALUES (?)', (roaming_id,))
        conn.commit()
    except sqlite3.IntegrityError:
        # This error means the roaming_id already exists.
        # We DO NOT inform the user. We simply 'pass' and return the same
        # generic message as the success case. This is the core of the fix.
        pass
    finally:
        conn.close()

    # This generic response is returned for BOTH new and duplicate registrations.
    # It promotes the platform's incentive program as the next step.
    return jsonify({
        "message": "Registration request processed.",
        "next_steps": [
            "You can now log in using your daily username.",
            "As a new member, you're eligible for special incentives! Create a parallel account to unlock them."
        ]
    }), 202 # 202 Accepted is more appropriate than 201 Created now.

@app.route('/itimestampd/login', methods=['POST'])
def login():
    """Handles user login using the 'ItimestampD' module."""
    data = request.get_json()
    roaming_id = data.get('roaming_id')
    provided_username = data.get('username')

    if not roaming_id or not provided_username:
        return jsonify({"error": "Roaming ID and username are required."}), 400

    conn = get_db_connection()
    user = conn.execute('SELECT * FROM users WHERE roaming_id = ?', (roaming_id,)).fetchone()

    if not user:
        conn.close()
        # Note: A generic message is also better here than "Invalid Roaming ID".
        return jsonify({"error": "Invalid credentials."}), 401

    expected_username = get_daily_username(roaming_id)

    if provided_username == expected_username:
        conn.execute('INSERT INTO login_records (user_id, login_username) VALUES (?, ?)',
                     (user['id'], provided_username))
        conn.commit()
        conn.close()
        return jsonify({
            "message": "Access Granted",
            "navigation_hint": "Proceed to /user/profile to see your options.",
            "auth_username": expected_username # Pass back the username for subsequent API calls
        }), 200
    else:
        conn.close()
        return jsonify({"error": "Invalid credentials."}), 401

@app.route('/user/profile', methods=['GET'])
def get_user_profile():
    """
    A post-login navigation hub.
    It uses the daily username from the header to identify the user and show
    conditional menu options.
    """
    auth_username = request.headers.get('X-Auth-Username')
    if not auth_username:
        return jsonify({"error": "Authentication username required."}), 401

    conn = get_db_connection()
    # Find the user_id from a recent, valid login record.
    record = conn.execute(
        'SELECT user_id FROM login_records WHERE login_username = ? ORDER BY login_timestamp DESC LIMIT 1',
        (auth_username,)
    ).fetchone()

    if not record:
        conn.close()
        return jsonify({"error": "Invalid or expired session username."}), 403

    user_id = record['user_id']
    # Check if the user has registered a biometric key
    biometric_key = conn.execute('SELECT id FROM biometric_keys WHERE user_id = ?', (user_id,)).fetchone()
    conn.close()

    # Conditional Menu Options
    menu_options = {
        "View Resources": "/resource/project_plan.txt",
        "Manage Devices": "/user/devices", # Conceptual endpoint
    }
    if not biometric_key:
        menu_options["Calibrate Bio-Sign On"] = "/user/biometric/register-start"
    else:
        menu_options["Biometric Options"] = "/user/biometric/manage"

    return jsonify({
        "welcome_message": f"User {user_id}, you are authenticated.",
        "daily_username": auth_username,
        "navigation_menu": menu_options
    }), 200

@app.route('/user/biometric/register-start', methods=['POST'])
def biometric_register_start():
    """
    CONCEPTUAL: First step for registering a new biometric authenticator.
    A real implementation would use a library to generate a cryptographically
    secure challenge.
    """
    # This endpoint would be protected, requiring the X-Auth-Username header
    auth_username = request.headers.get('X-Auth-Username')
    if not auth_username:
        return jsonify({"error": "Authentication username required."}), 401

    # In a real WebAuthn flow, you would generate a unique, random challenge
    # and associate it with the user's session.
    challenge = "a_very_long_and_random_challenge_string"
    user_id_from_session = 1 # Placeholder for looking up user from auth_username

    return jsonify({
        "message": "Biometric registration initiated. Sign this challenge with your device.",
        "user_id": user_id_from_session,
        "challenge": challenge
    }), 200

@app.route('/resource/<filename>', methods=['GET'])
def get_resource(filename):
    """Grants access to a file based on the user's daily username."""
    auth_username = request.headers.get('X-Auth-Username')
    if not auth_username:
        return jsonify({"error": "Authentication username required."}), 401
    # ... (rest of the function is unchanged, as its logic is sound for the demo)
    try:
        with open('access_control.json', 'r') as f:
            access_rules = json.load(f)
    except FileNotFoundError:
        return jsonify({"error": "Access control file not found."}), 500
    conn = get_db_connection()
    record = conn.execute('SELECT * FROM login_records WHERE login_username = ?', (auth_username,)).fetchone()
    conn.close()
    if not record:
        return jsonify({"error": "Invalid or expired username."}), 403
    if filename in access_rules.get("user", []):
        return jsonify({
            "message": f"Access to '{filename}' granted.",
            "content": f"This is the content of {filename}."
        }), 200
    else:
        return jsonify({"error": f"You do not have permission to access '{filename}'."}), 403

if __name__ == '__main__':
    create_tables()
    print("--- KAiSurf App v2.1 Initialized ---")
    print("Database and tables are ready.")
    print("Now supports user enumeration protection and biometric framework.")
    print("--------------------------------------")
    app.run(debug=True)